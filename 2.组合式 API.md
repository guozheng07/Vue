
# setup()
## 使用场景
setup() 钩子是在组件中使用组合式 API 的入口，通常只在以下情况下使用。**其他情况下，都应优先使用 <script setup> 语法。**
- 需要在非单文件组件中使用组合式 API 时。
- 需要在基于选项式 API 的组件中集成基于组合式 API 的代码时。  

## 基本使用
我们可以使用响应式 API 来声明响应式的状态，在 setup() 函数中返回的对象会暴露给模板和组件实例。其它的选项也可以通过组件实例来获取 setup() 暴露的属性。  
在模板中访问从 setup 返回的 ref 时，它会自动浅层解包，你无须再在模板中为它写 .value。当通过 this 访问时也会同样如此解包。  

## 参数
setup 函数的第一个参数是组件的 props。**一个 setup 函数的。props 是响应式的，并且会在传入新的 props 时同步更新。**  
- **如果你解构了 props 对象，解构出的变量将会丢失响应性。推荐通过 props.xxx 的形式来使用其中的 props。**  
- **确实需要解构 props 对象，或者需要将某个 prop 传到一个外部函数中并保持响应性，可以使用 toRefs() 和 toRef() 这两个工具函数**  
- props 的使用方式：  
```
import { toRefs, toRef } from 'vue'
export default {
  setup(props) {
    // 将 `props` 转为一个其中全是 ref 的对象，然后解构
    const { title } = toRefs(props)
    // `title` 是一个追踪着 `props.title` 的 ref
    console.log(title.value)

    // 或者，将 `props` 的单个属性转为一个 ref
    const title = toRef(props, 'title')
  }
}
```
setup 函数的第二个参数是一个 Setup 上下文对象。**上下文对象暴露了其他一些在 setup 中可能会用到的值：attrs、slots、emit、expose。**  
- **该上下文对象是非响应式的，可以安全地解构。** 
- **attrs 和 slots 都是有状态的对象，它们总是会随着组件自身的更新而更新。这意味着你应当避免解构它们，并始终通过 attrs.x 或 slots.x 的形式使用其中的属性。**  
- 和 props 不同，**attrs 和 slots 的属性都不是响应式的。**想要基于 attrs 或 slots 的改变来执行副作用，应该在 **onBeforeUpdate** 生命周期钩子中编写相关逻辑。
- context 的使用方式：  
```
// 1.解构
export default {
  setup(props, { attrs, slots, emit, expose }) {
    ...
  }
}
// 2.不解构
export default {
  setup(props, context) {
    // 透传 Attributes（非响应式的对象，等价于 $attrs）
    console.log(context.attrs)

    // 插槽（非响应式的对象，等价于 $slots）
    console.log(context.slots)

    // 触发事件（函数，等价于 $emit）
    console.log(context.emit)

    // 暴露公共属性（函数）
    console.log(context.expose)
  }
}
```
- expose 函数用于显式地限制该组件暴露出的属性：  
```
// 当父组件通过模板引用访问该组件的实例时，将仅能访问 expose 函数暴露出的内容
export default {
  setup(props, { expose }) {
    // 让组件实例处于 “关闭状态”，即不向父组件暴露任何东西
    expose()

    const publicCount = ref(0)
    const privateCount = ref(0)
    // 有选择地暴露局部状态
    expose({ count: publicCount })
  }
}
```
## 与渲染函数一起使用
**setup 也可以返回一个渲染函数**，该函数可以直接使用在同一作用域下声明的响应式状态：
```
import { h, ref } from 'vue'

export default {
  setup() {
    const count = ref(0)
    return () => h('div', count.value)
  }
}
```  
返回一个渲染函数将会阻止我们返回其他东西。对于组件内部来说，这样没有问题，但如果我们想通过模板引用将这个组件的方法暴露给父组件，那就有问题了。可以通过调用 expose() 解决这个问题： 
```  
// 此时父组件可以通过模板引用来访问这个 increment 方法。
import { h, ref } from 'vue'

export default {
  setup(props, { expose }) {
    const count = ref(0)
    const increment = () => ++count.value

    expose({
      increment
    })

    return () => h('div', count.value)
  }
}
```

# 响应式-核心 API
## ref()
作用：**接受一个内部值，返回一个响应式的、可更改的、只带 .value 属性的 ref 对象**。  
说明：  
- ref 对象是可更改的，即可以为 .value 赋予新的值。它也是响应式的，即所有对 .value 的操作都将被追踪，并且写操作会触发与之相关的副作用。
- **如果将一个对象赋值给 ref，那么这个对象将通过 reactive() 转为具有深层次响应式的对象。这也意味着如果对象中包含了嵌套的 ref，它们将被深层地解包。**
  若要避免这种深层次的转换，请使用 shallowRef() 来替代。
- **ref 在模板中的解包：仅当 ref 是模板渲染上下文的顶层属性时才适用自动“解包”。**
- **ref 在响应式对象中的解包：当一个 ref 被嵌套在一个响应式对象中，作为属性被访问或更改时，它会自动解包。**
  将一个新的 ref 赋值给一个关联了已有 ref 的属性，那么它会替换掉旧的 ref。**当 ref 被嵌套在一个深层响应式对象内时，才会发生 ref 解包，当其作为浅层响应式对象（shallowReactive 等）的属性被访问时不会解包。**
- 数组和集合类型的 ref 解包：当 ref 作为响应式数组或像 Map 这种原生集合类型的元素被访问时，不会进行解包。
使用：  
```
// 1.一个包含对象类型值的 ref 可以响应式地替换整个对象
const objectRef = ref({ count: 0 })

// 这是响应式的替换
objectRef.value = { count: 1 }
  
// 2.ref 被传递给函数或是从一般对象上被解构时，不会丢失响应性
const obj = {
  foo: ref(1),
  bar: ref(2)
}

// 该函数接收一个 ref，需要通过 .value 取值，但它会保持响应性
callSomeFunction(obj.foo)

// 仍然是响应式的
const { foo, bar } = obj

// 3.ref 在响应式对象中的解包
const count = ref(0)
const state = reactive({
  count
})

console.log(state.count) // 0
state.count = 1
console.log(count.value) // 1

const otherCount = ref(2)
state.count = otherCount
console.log(state.count) // 2
// 原始 ref 现在已经和 state.count 失去联系
console.log(count.value) // 1

// 4.数组和集合类型的 ref 解包
const books = reactive([ref('Vue 3 Guide')])
// 这里需要 .value
console.log(books[0].value)

const map = reactive(new Map([['count', ref(0)]]))
// 这里需要 .value
console.log(map.get('count').value)
```
## reactive()
作用：返回一个对象的响应式代理。  
说明：  
- 响应式转换是“深层”的：它会影响到所有嵌套的属性。一个响应式对象也将深层地解包任何 ref 属性，同时保持响应性。
- 当访问到某个响应式数组或 Map 这样的原生集合类型中的 ref 元素时，不会执行 ref 的解包。
- 若要避免深层响应式转换，只想保留对这个对象顶层次访问的响应性，请使用 shallowReactive() 作替代。
- 返回的对象以及其中嵌套的对象都会通过 ES Proxy 包裹，因此不等于源对象，建议只使用响应式代理，避免使用原始对象。
- 将一个 ref 赋值给为一个 reactive 属性时，该 ref 会被自动解包。
```
const count = ref(1)
const obj = reactive({})

obj.count = count

console.log(obj.count) // 1
console.log(obj.count === count.value) // true
```

## computed ()
作用：计算属性。  
使用：  
```
// 1.创建一个只读的计算属性 ref
const count = ref(1)
const plusOne = computed(() => count.value + 1)

console.log(plusOne.value) // 2

plusOne.value++ // 错误

// 2.创建一个可写的计算属性 ref
const count = ref(1)
const plusOne = computed({
  get: () => count.value + 1,
  set: (val) => {
    count.value = val - 1
  }
})

plusOne.value = 1
console.log(count.value) // 0
```

## watch
作用：侦听一个或多个响应式数据源，并在数据源变化时调用所给的回调函数。  
参数：  
- 第一个参数是侦听器的源。这个来源可以是`一个函数，返回一个值`、`一个 ref`、`一个响应式对象`、`...或是由以上类型的值组成的数组`。
- 第二个参数是在发生变化时要调用的回调函数。这个回调函数接受三个参数：新值、旧值，以及一个用于注册副作用清理的回调函数。**该回调函数会在副作用下一次重新执行前调用，可以用来清除无效的副作用，例如等待中的异步请求。** **当侦听多个来源时，回调函数接受两个数组，分别对应来源数组中的新值和旧值。**
- 第三个可选的参数是一个对象，支持以下这些选项：
  - immediate：在侦听器创建时立即触发回调。第一次调用时旧值是 undefined。
  - deep：如果源是对象，强制深度遍历，以便在深层级变更时触发回调。
  - flush：调整回调函数的刷新时机。
  - onTrack / onTrigger：调试侦听器的依赖。  
说明：  
- watch() 默认是懒侦听的，即仅在侦听源发生变化时才执行回调函数。
- 相对于 watchEffect() 的优势：
  - 懒执行副作用。
  - 更加明确是应该由哪个状态触发侦听器重新执行。
  - 可以访问所侦听状态的前一个值和当前值。  
使用：  
```
// 当侦听多个来源时，回调函数接受两个数组，分别对应来源数组中的新值和旧值
watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) => {
  /* ... */
})
```

## watchEffect()
作用：立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。  
说明：
- 第一个参数就是要运行的副作用函数。这个副作用函数的参数也是一个函数，用来注册清理回调。清理回调会在该副作用下一次执行前被调用，可以用来清理无效的副作用，例如等待中的异步请求。
- **第二个参数是一个可选的选项，可以用来调整副作用的刷新时机或调试副作用的依赖。**
- 默认情况下，侦听器将在组件渲染之前执行。设置 flush: 'post' 将会使侦听器延迟到组件渲染之后再执行。在某些特殊情况下 (例如要使缓存失效)，可能有必要在响应式依赖发生改变时立即触发侦听器。这可以通过设置 flush: 'sync' 来实现。然而，该设置应谨慎使用，因为如果有多个属性同时更新，这将导致一些性能和数据一致性的问题。
- 返回值是一个用来停止该副作用的函数。  
使用：  
```
const count = ref(0)
watchEffect(() => console.log(count.value))
// -> 输出 0
count.value++
// -> 输出 1

// 副作用清除
watchEffect(async (onCleanup) => {
  const { response, cancel } = doAsyncWork(id.value)
  // `cancel` 会在 `id` 更改时调用，以便取消之前未完成的请求
  onCleanup(cancel)
  data.value = await response
})
  
// 停止侦听器
const stop = watchEffect(() => {})
// 当不再需要此侦听器时:
stop()
```

## readonly()
作用：接受一个对象 (不论是响应式还是普通的) 或是一个 ref，返回一个原值的只读代理。
说明：  
- 只读代理是深层的：对任何嵌套属性的访问都将是只读的。它的 ref 解包行为与 reactive() 相同，但解包得到的值是只读的。
- 要避免深层级的转换行为，请使用 shallowReadonly() 作替代。  
使用：  
```
const original = reactive({ count: 0 })

const copy = readonly(original)

watchEffect(() => {
  // 用来做响应性追踪
  console.log(copy.count)
})

// 更改源属性会触发其依赖的侦听器
original.count++

// 更改该只读副本将会失败，并会得到一个警告
copy.count++ // warning!
```

# 响应式-工具 API

# 响应式-进阶 API
  
# 生命周期钩子

# 依赖注入
  



